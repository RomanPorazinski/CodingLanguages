# Syntax rules
## Variable naming
### Naming conventions
There are different styles of naming conventions which need to be picked. 
1) CamelCapitalisationOfEveryName
2) Spacing_option_for_legibility
3) littleCamelCapitalsation (first word starts with small letter)

My preference is option 1.

Regardless of which style you pick from the ones available above, you should also add a prefix to define the data type of the used variable to allow for easier code integration and reduce type mismatches

| Prefix | Data Type      |
| ------ | -------------- |
| b      | boolean        |
| f      | float          |
| i      | integer        |
| s      | signed integer |
| d      | double         |
If you are working with pointers then you would add a p before the above prefix so that the user know what kind of a pointer it is i.e:
	piCowCountInField -> pointer to an integer storing the number of cows counted on the field
You can also follow the F1 naming convention when creating diagnostic signals to be displayed.

| Prefix | Data Type |
| ------ | --------- |
|        |           |

### Reusing names across different scopes
The same variable name can be used in the code and won't croscontaminate the functionality as long as you understand the scope in which it exists. In the example below, you can see a lot of same variables that are called
```c
int main(void)
{
[1] -> //scope 1
int j;
f(5);
printf("%d\n", j);
return 0
}

void f(int i) {
[2] -> //scope 2
int j = 1;
printf("i at the start of function is %d\n", i);
i++;
printf("i after increment is %d\n", i);
for (int i = 0; i < 2; i++){
	[3] -> // scope 3
    int j = 2;
    printf("j is now %d\n", j);
    printf("i is now %d\n", i);
}
printf("j after the for loop is %d\n", j);
printf("i after the for loop is %d\n", i);
}
```
The code above has been divided into 3 scopes, all using the same variables i and j. The above code delivers the following content in the terminal:
```txt
i at the start of function is 5 [Scope 2]
i after increment is 6 [Scope 2]
j is now 2 [Scope 3]
i is now 0 [Scope 3]
j is now 2 [Scope 3]
i is now 1 [Scope 3]
j after the for loop is 1 [Scope 2]
i after the for loop is 6 [Scope 2]
0 [Scope 1]
```
1) i is first equal to the function argument and then gets incremented
2) We enter the for loop after that and i is initialised to a 0 as a loop counter. j is consistently set to 2 during the for loop
3) Once the for loop is done, the variables i and j have the same values they had before the for loop so j=1 and i=6. For loop had its own scope
4) In the end, after the function f was executed, j in Scope 1 has never been initiated so it returned a 0 despite all the events inside of the function
This only works for **sub function** and **for loops** and not for *if statements* or *while loops*
git
### Understanding Storage Duration
